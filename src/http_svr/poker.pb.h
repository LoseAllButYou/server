// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: poker.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_poker_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_poker_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_poker_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_poker_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[11]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_poker_2eproto;
namespace PokerGame {
class config_room;
class config_roomDefaultTypeInternal;
extern config_roomDefaultTypeInternal _config_room_default_instance_;
class create_room;
class create_roomDefaultTypeInternal;
extern create_roomDefaultTypeInternal _create_room_default_instance_;
class deal_cards;
class deal_cardsDefaultTypeInternal;
extern deal_cardsDefaultTypeInternal _deal_cards_default_instance_;
class fold_cards;
class fold_cardsDefaultTypeInternal;
extern fold_cardsDefaultTypeInternal _fold_cards_default_instance_;
class game_info;
class game_infoDefaultTypeInternal;
extern game_infoDefaultTypeInternal _game_info_default_instance_;
class get_cards;
class get_cardsDefaultTypeInternal;
extern get_cardsDefaultTypeInternal _get_cards_default_instance_;
class msg_package;
class msg_packageDefaultTypeInternal;
extern msg_packageDefaultTypeInternal _msg_package_default_instance_;
class play_cards;
class play_cardsDefaultTypeInternal;
extern play_cardsDefaultTypeInternal _play_cards_default_instance_;
class response;
class responseDefaultTypeInternal;
extern responseDefaultTypeInternal _response_default_instance_;
class room_conf;
class room_confDefaultTypeInternal;
extern room_confDefaultTypeInternal _room_conf_default_instance_;
class seats_info;
class seats_infoDefaultTypeInternal;
extern seats_infoDefaultTypeInternal _seats_info_default_instance_;
}  // namespace PokerGame
PROTOBUF_NAMESPACE_OPEN
template<> ::PokerGame::config_room* Arena::CreateMaybeMessage<::PokerGame::config_room>(Arena*);
template<> ::PokerGame::create_room* Arena::CreateMaybeMessage<::PokerGame::create_room>(Arena*);
template<> ::PokerGame::deal_cards* Arena::CreateMaybeMessage<::PokerGame::deal_cards>(Arena*);
template<> ::PokerGame::fold_cards* Arena::CreateMaybeMessage<::PokerGame::fold_cards>(Arena*);
template<> ::PokerGame::game_info* Arena::CreateMaybeMessage<::PokerGame::game_info>(Arena*);
template<> ::PokerGame::get_cards* Arena::CreateMaybeMessage<::PokerGame::get_cards>(Arena*);
template<> ::PokerGame::msg_package* Arena::CreateMaybeMessage<::PokerGame::msg_package>(Arena*);
template<> ::PokerGame::play_cards* Arena::CreateMaybeMessage<::PokerGame::play_cards>(Arena*);
template<> ::PokerGame::response* Arena::CreateMaybeMessage<::PokerGame::response>(Arena*);
template<> ::PokerGame::room_conf* Arena::CreateMaybeMessage<::PokerGame::room_conf>(Arena*);
template<> ::PokerGame::seats_info* Arena::CreateMaybeMessage<::PokerGame::seats_info>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace PokerGame {

enum PokerGameID : int {
  ERR_ID = 0,
  HEART = 1,
  CREATE_ROOM = 2,
  RES_CREATE_ROOM = 3,
  DELETE_ROOM = 4,
  RES_DELETE_ROOM = 5,
  JOIN_ROOM = 6,
  RES_JOIN_ROOM = 7,
  LEAVE_ROOM = 8,
  RES_LEAVE_ROOM = 9,
  START_GAME = 10,
  RES_START_GAME = 11,
  OVER_GAME = 12,
  RES_OVER_GAME = 13,
  DEAL_CARDS = 14,
  PLAY_CARDS = 15,
  RES_PLAY_CARDS = 16,
  FOLD_CARDS = 17,
  RES_FOLD_CARDS = 18,
  GET_CARDS = 19,
  RES_GET_CARDS = 20,
  CLEAR_PLAY_CARDS = 21,
  RES_CLEAR_PLAY_CARDS = 22,
  CONFIG_ROOM = 23,
  RES_CONFIG_ROOM = 24,
  PokerGameID_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PokerGameID_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PokerGameID_IsValid(int value);
constexpr PokerGameID PokerGameID_MIN = ERR_ID;
constexpr PokerGameID PokerGameID_MAX = RES_CONFIG_ROOM;
constexpr int PokerGameID_ARRAYSIZE = PokerGameID_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PokerGameID_descriptor();
template<typename T>
inline const std::string& PokerGameID_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PokerGameID>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PokerGameID_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PokerGameID_descriptor(), enum_t_value);
}
inline bool PokerGameID_Parse(
    const std::string& name, PokerGameID* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PokerGameID>(
    PokerGameID_descriptor(), name, value);
}
enum RET_CODE : int {
  DEFAULT = 0,
  SUCCESS = 1,
  ERR_REQUEST = 2,
  RET_CODE_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  RET_CODE_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool RET_CODE_IsValid(int value);
constexpr RET_CODE RET_CODE_MIN = DEFAULT;
constexpr RET_CODE RET_CODE_MAX = ERR_REQUEST;
constexpr int RET_CODE_ARRAYSIZE = RET_CODE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RET_CODE_descriptor();
template<typename T>
inline const std::string& RET_CODE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RET_CODE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RET_CODE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RET_CODE_descriptor(), enum_t_value);
}
inline bool RET_CODE_Parse(
    const std::string& name, RET_CODE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RET_CODE>(
    RET_CODE_descriptor(), name, value);
}
// ===================================================================

class msg_package :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PokerGame.msg_package) */ {
 public:
  msg_package();
  virtual ~msg_package();

  msg_package(const msg_package& from);
  msg_package(msg_package&& from) noexcept
    : msg_package() {
    *this = ::std::move(from);
  }

  inline msg_package& operator=(const msg_package& from) {
    CopyFrom(from);
    return *this;
  }
  inline msg_package& operator=(msg_package&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const msg_package& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const msg_package* internal_default_instance() {
    return reinterpret_cast<const msg_package*>(
               &_msg_package_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(msg_package& a, msg_package& b) {
    a.Swap(&b);
  }
  inline void Swap(msg_package* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline msg_package* New() const final {
    return CreateMaybeMessage<msg_package>(nullptr);
  }

  msg_package* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<msg_package>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const msg_package& from);
  void MergeFrom(const msg_package& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(msg_package* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PokerGame.msg_package";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_poker_2eproto);
    return ::descriptor_table_poker_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReqPkgFieldNumber = 4,
    kResPkgFieldNumber = 5,
    kIdFieldNumber = 1,
    kUserIdFieldNumber = 2,
    kRoomIdFieldNumber = 3,
  };
  // bytes req_pkg = 4;
  void clear_req_pkg();
  const std::string& req_pkg() const;
  void set_req_pkg(const std::string& value);
  void set_req_pkg(std::string&& value);
  void set_req_pkg(const char* value);
  void set_req_pkg(const void* value, size_t size);
  std::string* mutable_req_pkg();
  std::string* release_req_pkg();
  void set_allocated_req_pkg(std::string* req_pkg);

  // .PokerGame.response res_pkg = 5;
  bool has_res_pkg() const;
  void clear_res_pkg();
  const ::PokerGame::response& res_pkg() const;
  ::PokerGame::response* release_res_pkg();
  ::PokerGame::response* mutable_res_pkg();
  void set_allocated_res_pkg(::PokerGame::response* res_pkg);

  // int32 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 user_id = 2;
  void clear_user_id();
  ::PROTOBUF_NAMESPACE_ID::int32 user_id() const;
  void set_user_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 room_id = 3;
  void clear_room_id();
  ::PROTOBUF_NAMESPACE_ID::int32 room_id() const;
  void set_room_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:PokerGame.msg_package)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr req_pkg_;
  ::PokerGame::response* res_pkg_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  ::PROTOBUF_NAMESPACE_ID::int32 user_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 room_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_poker_2eproto;
};
// -------------------------------------------------------------------

class response :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PokerGame.response) */ {
 public:
  response();
  virtual ~response();

  response(const response& from);
  response(response&& from) noexcept
    : response() {
    *this = ::std::move(from);
  }

  inline response& operator=(const response& from) {
    CopyFrom(from);
    return *this;
  }
  inline response& operator=(response&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const response& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const response* internal_default_instance() {
    return reinterpret_cast<const response*>(
               &_response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(response& a, response& b) {
    a.Swap(&b);
  }
  inline void Swap(response* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline response* New() const final {
    return CreateMaybeMessage<response>(nullptr);
  }

  response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<response>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const response& from);
  void MergeFrom(const response& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(response* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PokerGame.response";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_poker_2eproto);
    return ::descriptor_table_poker_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResonFieldNumber = 2,
    kPkgFieldNumber = 3,
    kRetFieldNumber = 1,
  };
  // string reson = 2;
  void clear_reson();
  const std::string& reson() const;
  void set_reson(const std::string& value);
  void set_reson(std::string&& value);
  void set_reson(const char* value);
  void set_reson(const char* value, size_t size);
  std::string* mutable_reson();
  std::string* release_reson();
  void set_allocated_reson(std::string* reson);

  // bytes pkg = 3;
  void clear_pkg();
  const std::string& pkg() const;
  void set_pkg(const std::string& value);
  void set_pkg(std::string&& value);
  void set_pkg(const char* value);
  void set_pkg(const void* value, size_t size);
  std::string* mutable_pkg();
  std::string* release_pkg();
  void set_allocated_pkg(std::string* pkg);

  // .PokerGame.RET_CODE ret = 1;
  void clear_ret();
  ::PokerGame::RET_CODE ret() const;
  void set_ret(::PokerGame::RET_CODE value);

  // @@protoc_insertion_point(class_scope:PokerGame.response)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reson_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pkg_;
  int ret_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_poker_2eproto;
};
// -------------------------------------------------------------------

class create_room :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PokerGame.create_room) */ {
 public:
  create_room();
  virtual ~create_room();

  create_room(const create_room& from);
  create_room(create_room&& from) noexcept
    : create_room() {
    *this = ::std::move(from);
  }

  inline create_room& operator=(const create_room& from) {
    CopyFrom(from);
    return *this;
  }
  inline create_room& operator=(create_room&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const create_room& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const create_room* internal_default_instance() {
    return reinterpret_cast<const create_room*>(
               &_create_room_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(create_room& a, create_room& b) {
    a.Swap(&b);
  }
  inline void Swap(create_room* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline create_room* New() const final {
    return CreateMaybeMessage<create_room>(nullptr);
  }

  create_room* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<create_room>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const create_room& from);
  void MergeFrom(const create_room& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(create_room* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PokerGame.create_room";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_poker_2eproto);
    return ::descriptor_table_poker_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfFieldNumber = 2,
    kRoomIdFieldNumber = 1,
  };
  // .PokerGame.room_conf conf = 2;
  bool has_conf() const;
  void clear_conf();
  const ::PokerGame::room_conf& conf() const;
  ::PokerGame::room_conf* release_conf();
  ::PokerGame::room_conf* mutable_conf();
  void set_allocated_conf(::PokerGame::room_conf* conf);

  // int32 room_id = 1;
  void clear_room_id();
  ::PROTOBUF_NAMESPACE_ID::int32 room_id() const;
  void set_room_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:PokerGame.create_room)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PokerGame::room_conf* conf_;
  ::PROTOBUF_NAMESPACE_ID::int32 room_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_poker_2eproto;
};
// -------------------------------------------------------------------

class room_conf :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PokerGame.room_conf) */ {
 public:
  room_conf();
  virtual ~room_conf();

  room_conf(const room_conf& from);
  room_conf(room_conf&& from) noexcept
    : room_conf() {
    *this = ::std::move(from);
  }

  inline room_conf& operator=(const room_conf& from) {
    CopyFrom(from);
    return *this;
  }
  inline room_conf& operator=(room_conf&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const room_conf& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const room_conf* internal_default_instance() {
    return reinterpret_cast<const room_conf*>(
               &_room_conf_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(room_conf& a, room_conf& b) {
    a.Swap(&b);
  }
  inline void Swap(room_conf* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline room_conf* New() const final {
    return CreateMaybeMessage<room_conf>(nullptr);
  }

  room_conf* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<room_conf>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const room_conf& from);
  void MergeFrom(const room_conf& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(room_conf* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PokerGame.room_conf";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_poker_2eproto);
    return ::descriptor_table_poker_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJokerFieldNumber = 1,
    kDealerFieldNumber = 2,
    kPlayersNumFieldNumber = 3,
    kPokersNumFieldNumber = 4,
    kTypeFieldNumber = 5,
    kDealNumFieldNumber = 6,
  };
  // bool joker = 1;
  void clear_joker();
  bool joker() const;
  void set_joker(bool value);

  // bool dealer = 2;
  void clear_dealer();
  bool dealer() const;
  void set_dealer(bool value);

  // int32 players_num = 3;
  void clear_players_num();
  ::PROTOBUF_NAMESPACE_ID::int32 players_num() const;
  void set_players_num(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 pokers_num = 4;
  void clear_pokers_num();
  ::PROTOBUF_NAMESPACE_ID::int32 pokers_num() const;
  void set_pokers_num(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 type = 5;
  void clear_type();
  ::PROTOBUF_NAMESPACE_ID::int32 type() const;
  void set_type(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 deal_num = 6;
  void clear_deal_num();
  ::PROTOBUF_NAMESPACE_ID::int32 deal_num() const;
  void set_deal_num(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:PokerGame.room_conf)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  bool joker_;
  bool dealer_;
  ::PROTOBUF_NAMESPACE_ID::int32 players_num_;
  ::PROTOBUF_NAMESPACE_ID::int32 pokers_num_;
  ::PROTOBUF_NAMESPACE_ID::int32 type_;
  ::PROTOBUF_NAMESPACE_ID::int32 deal_num_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_poker_2eproto;
};
// -------------------------------------------------------------------

class seats_info :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PokerGame.seats_info) */ {
 public:
  seats_info();
  virtual ~seats_info();

  seats_info(const seats_info& from);
  seats_info(seats_info&& from) noexcept
    : seats_info() {
    *this = ::std::move(from);
  }

  inline seats_info& operator=(const seats_info& from) {
    CopyFrom(from);
    return *this;
  }
  inline seats_info& operator=(seats_info&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const seats_info& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const seats_info* internal_default_instance() {
    return reinterpret_cast<const seats_info*>(
               &_seats_info_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(seats_info& a, seats_info& b) {
    a.Swap(&b);
  }
  inline void Swap(seats_info* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline seats_info* New() const final {
    return CreateMaybeMessage<seats_info>(nullptr);
  }

  seats_info* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<seats_info>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const seats_info& from);
  void MergeFrom(const seats_info& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(seats_info* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PokerGame.seats_info";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_poker_2eproto);
    return ::descriptor_table_poker_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHandsFieldNumber = 3,
    kPlayCardsFieldNumber = 5,
    kIdFieldNumber = 1,
    kUserIdFieldNumber = 2,
    kHandsNumFieldNumber = 4,
  };
  // string hands = 3;
  void clear_hands();
  const std::string& hands() const;
  void set_hands(const std::string& value);
  void set_hands(std::string&& value);
  void set_hands(const char* value);
  void set_hands(const char* value, size_t size);
  std::string* mutable_hands();
  std::string* release_hands();
  void set_allocated_hands(std::string* hands);

  // string play_cards = 5;
  void clear_play_cards();
  const std::string& play_cards() const;
  void set_play_cards(const std::string& value);
  void set_play_cards(std::string&& value);
  void set_play_cards(const char* value);
  void set_play_cards(const char* value, size_t size);
  std::string* mutable_play_cards();
  std::string* release_play_cards();
  void set_allocated_play_cards(std::string* play_cards);

  // int32 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 user_id = 2;
  void clear_user_id();
  ::PROTOBUF_NAMESPACE_ID::int32 user_id() const;
  void set_user_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 hands_num = 4;
  void clear_hands_num();
  ::PROTOBUF_NAMESPACE_ID::int32 hands_num() const;
  void set_hands_num(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:PokerGame.seats_info)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hands_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr play_cards_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  ::PROTOBUF_NAMESPACE_ID::int32 user_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 hands_num_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_poker_2eproto;
};
// -------------------------------------------------------------------

class game_info :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PokerGame.game_info) */ {
 public:
  game_info();
  virtual ~game_info();

  game_info(const game_info& from);
  game_info(game_info&& from) noexcept
    : game_info() {
    *this = ::std::move(from);
  }

  inline game_info& operator=(const game_info& from) {
    CopyFrom(from);
    return *this;
  }
  inline game_info& operator=(game_info&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const game_info& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const game_info* internal_default_instance() {
    return reinterpret_cast<const game_info*>(
               &_game_info_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(game_info& a, game_info& b) {
    a.Swap(&b);
  }
  inline void Swap(game_info* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline game_info* New() const final {
    return CreateMaybeMessage<game_info>(nullptr);
  }

  game_info* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<game_info>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const game_info& from);
  void MergeFrom(const game_info& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(game_info* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PokerGame.game_info";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_poker_2eproto);
    return ::descriptor_table_poker_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSeatsFieldNumber = 3,
    kCommCardsFieldNumber = 4,
    kConfFieldNumber = 2,
    kStateFieldNumber = 1,
  };
  // repeated .PokerGame.seats_info seats = 3;
  int seats_size() const;
  void clear_seats();
  ::PokerGame::seats_info* mutable_seats(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PokerGame::seats_info >*
      mutable_seats();
  const ::PokerGame::seats_info& seats(int index) const;
  ::PokerGame::seats_info* add_seats();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PokerGame::seats_info >&
      seats() const;

  // string comm_cards = 4;
  void clear_comm_cards();
  const std::string& comm_cards() const;
  void set_comm_cards(const std::string& value);
  void set_comm_cards(std::string&& value);
  void set_comm_cards(const char* value);
  void set_comm_cards(const char* value, size_t size);
  std::string* mutable_comm_cards();
  std::string* release_comm_cards();
  void set_allocated_comm_cards(std::string* comm_cards);

  // .PokerGame.room_conf conf = 2;
  bool has_conf() const;
  void clear_conf();
  const ::PokerGame::room_conf& conf() const;
  ::PokerGame::room_conf* release_conf();
  ::PokerGame::room_conf* mutable_conf();
  void set_allocated_conf(::PokerGame::room_conf* conf);

  // int32 state = 1;
  void clear_state();
  ::PROTOBUF_NAMESPACE_ID::int32 state() const;
  void set_state(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:PokerGame.game_info)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PokerGame::seats_info > seats_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comm_cards_;
  ::PokerGame::room_conf* conf_;
  ::PROTOBUF_NAMESPACE_ID::int32 state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_poker_2eproto;
};
// -------------------------------------------------------------------

class config_room :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PokerGame.config_room) */ {
 public:
  config_room();
  virtual ~config_room();

  config_room(const config_room& from);
  config_room(config_room&& from) noexcept
    : config_room() {
    *this = ::std::move(from);
  }

  inline config_room& operator=(const config_room& from) {
    CopyFrom(from);
    return *this;
  }
  inline config_room& operator=(config_room&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const config_room& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const config_room* internal_default_instance() {
    return reinterpret_cast<const config_room*>(
               &_config_room_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(config_room& a, config_room& b) {
    a.Swap(&b);
  }
  inline void Swap(config_room* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline config_room* New() const final {
    return CreateMaybeMessage<config_room>(nullptr);
  }

  config_room* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<config_room>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const config_room& from);
  void MergeFrom(const config_room& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(config_room* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PokerGame.config_room";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_poker_2eproto);
    return ::descriptor_table_poker_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfFieldNumber = 1,
  };
  // .PokerGame.room_conf conf = 1;
  bool has_conf() const;
  void clear_conf();
  const ::PokerGame::room_conf& conf() const;
  ::PokerGame::room_conf* release_conf();
  ::PokerGame::room_conf* mutable_conf();
  void set_allocated_conf(::PokerGame::room_conf* conf);

  // @@protoc_insertion_point(class_scope:PokerGame.config_room)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PokerGame::room_conf* conf_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_poker_2eproto;
};
// -------------------------------------------------------------------

class play_cards :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PokerGame.play_cards) */ {
 public:
  play_cards();
  virtual ~play_cards();

  play_cards(const play_cards& from);
  play_cards(play_cards&& from) noexcept
    : play_cards() {
    *this = ::std::move(from);
  }

  inline play_cards& operator=(const play_cards& from) {
    CopyFrom(from);
    return *this;
  }
  inline play_cards& operator=(play_cards&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const play_cards& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const play_cards* internal_default_instance() {
    return reinterpret_cast<const play_cards*>(
               &_play_cards_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(play_cards& a, play_cards& b) {
    a.Swap(&b);
  }
  inline void Swap(play_cards* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline play_cards* New() const final {
    return CreateMaybeMessage<play_cards>(nullptr);
  }

  play_cards* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<play_cards>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const play_cards& from);
  void MergeFrom(const play_cards& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(play_cards* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PokerGame.play_cards";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_poker_2eproto);
    return ::descriptor_table_poker_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCardsFieldNumber = 1,
  };
  // string cards = 1;
  void clear_cards();
  const std::string& cards() const;
  void set_cards(const std::string& value);
  void set_cards(std::string&& value);
  void set_cards(const char* value);
  void set_cards(const char* value, size_t size);
  std::string* mutable_cards();
  std::string* release_cards();
  void set_allocated_cards(std::string* cards);

  // @@protoc_insertion_point(class_scope:PokerGame.play_cards)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cards_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_poker_2eproto;
};
// -------------------------------------------------------------------

class fold_cards :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PokerGame.fold_cards) */ {
 public:
  fold_cards();
  virtual ~fold_cards();

  fold_cards(const fold_cards& from);
  fold_cards(fold_cards&& from) noexcept
    : fold_cards() {
    *this = ::std::move(from);
  }

  inline fold_cards& operator=(const fold_cards& from) {
    CopyFrom(from);
    return *this;
  }
  inline fold_cards& operator=(fold_cards&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const fold_cards& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const fold_cards* internal_default_instance() {
    return reinterpret_cast<const fold_cards*>(
               &_fold_cards_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(fold_cards& a, fold_cards& b) {
    a.Swap(&b);
  }
  inline void Swap(fold_cards* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline fold_cards* New() const final {
    return CreateMaybeMessage<fold_cards>(nullptr);
  }

  fold_cards* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<fold_cards>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const fold_cards& from);
  void MergeFrom(const fold_cards& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(fold_cards* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PokerGame.fold_cards";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_poker_2eproto);
    return ::descriptor_table_poker_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCardsFieldNumber = 1,
  };
  // string cards = 1;
  void clear_cards();
  const std::string& cards() const;
  void set_cards(const std::string& value);
  void set_cards(std::string&& value);
  void set_cards(const char* value);
  void set_cards(const char* value, size_t size);
  std::string* mutable_cards();
  std::string* release_cards();
  void set_allocated_cards(std::string* cards);

  // @@protoc_insertion_point(class_scope:PokerGame.fold_cards)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cards_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_poker_2eproto;
};
// -------------------------------------------------------------------

class deal_cards :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PokerGame.deal_cards) */ {
 public:
  deal_cards();
  virtual ~deal_cards();

  deal_cards(const deal_cards& from);
  deal_cards(deal_cards&& from) noexcept
    : deal_cards() {
    *this = ::std::move(from);
  }

  inline deal_cards& operator=(const deal_cards& from) {
    CopyFrom(from);
    return *this;
  }
  inline deal_cards& operator=(deal_cards&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const deal_cards& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const deal_cards* internal_default_instance() {
    return reinterpret_cast<const deal_cards*>(
               &_deal_cards_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(deal_cards& a, deal_cards& b) {
    a.Swap(&b);
  }
  inline void Swap(deal_cards* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline deal_cards* New() const final {
    return CreateMaybeMessage<deal_cards>(nullptr);
  }

  deal_cards* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<deal_cards>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const deal_cards& from);
  void MergeFrom(const deal_cards& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(deal_cards* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PokerGame.deal_cards";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_poker_2eproto);
    return ::descriptor_table_poker_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCardsFieldNumber = 1,
  };
  // string cards = 1;
  void clear_cards();
  const std::string& cards() const;
  void set_cards(const std::string& value);
  void set_cards(std::string&& value);
  void set_cards(const char* value);
  void set_cards(const char* value, size_t size);
  std::string* mutable_cards();
  std::string* release_cards();
  void set_allocated_cards(std::string* cards);

  // @@protoc_insertion_point(class_scope:PokerGame.deal_cards)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cards_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_poker_2eproto;
};
// -------------------------------------------------------------------

class get_cards :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PokerGame.get_cards) */ {
 public:
  get_cards();
  virtual ~get_cards();

  get_cards(const get_cards& from);
  get_cards(get_cards&& from) noexcept
    : get_cards() {
    *this = ::std::move(from);
  }

  inline get_cards& operator=(const get_cards& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_cards& operator=(get_cards&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const get_cards& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const get_cards* internal_default_instance() {
    return reinterpret_cast<const get_cards*>(
               &_get_cards_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(get_cards& a, get_cards& b) {
    a.Swap(&b);
  }
  inline void Swap(get_cards* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_cards* New() const final {
    return CreateMaybeMessage<get_cards>(nullptr);
  }

  get_cards* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_cards>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const get_cards& from);
  void MergeFrom(const get_cards& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_cards* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PokerGame.get_cards";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_poker_2eproto);
    return ::descriptor_table_poker_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCardsFieldNumber = 2,
    kNumFieldNumber = 1,
  };
  // string cards = 2;
  void clear_cards();
  const std::string& cards() const;
  void set_cards(const std::string& value);
  void set_cards(std::string&& value);
  void set_cards(const char* value);
  void set_cards(const char* value, size_t size);
  std::string* mutable_cards();
  std::string* release_cards();
  void set_allocated_cards(std::string* cards);

  // int32 num = 1;
  void clear_num();
  ::PROTOBUF_NAMESPACE_ID::int32 num() const;
  void set_num(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:PokerGame.get_cards)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cards_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_poker_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// msg_package

// int32 id = 1;
inline void msg_package::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 msg_package::id() const {
  // @@protoc_insertion_point(field_get:PokerGame.msg_package.id)
  return id_;
}
inline void msg_package::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:PokerGame.msg_package.id)
}

// int32 user_id = 2;
inline void msg_package::clear_user_id() {
  user_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 msg_package::user_id() const {
  // @@protoc_insertion_point(field_get:PokerGame.msg_package.user_id)
  return user_id_;
}
inline void msg_package::set_user_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  user_id_ = value;
  // @@protoc_insertion_point(field_set:PokerGame.msg_package.user_id)
}

// int32 room_id = 3;
inline void msg_package::clear_room_id() {
  room_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 msg_package::room_id() const {
  // @@protoc_insertion_point(field_get:PokerGame.msg_package.room_id)
  return room_id_;
}
inline void msg_package::set_room_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  room_id_ = value;
  // @@protoc_insertion_point(field_set:PokerGame.msg_package.room_id)
}

// bytes req_pkg = 4;
inline void msg_package::clear_req_pkg() {
  req_pkg_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& msg_package::req_pkg() const {
  // @@protoc_insertion_point(field_get:PokerGame.msg_package.req_pkg)
  return req_pkg_.GetNoArena();
}
inline void msg_package::set_req_pkg(const std::string& value) {
  
  req_pkg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PokerGame.msg_package.req_pkg)
}
inline void msg_package::set_req_pkg(std::string&& value) {
  
  req_pkg_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PokerGame.msg_package.req_pkg)
}
inline void msg_package::set_req_pkg(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  req_pkg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PokerGame.msg_package.req_pkg)
}
inline void msg_package::set_req_pkg(const void* value, size_t size) {
  
  req_pkg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PokerGame.msg_package.req_pkg)
}
inline std::string* msg_package::mutable_req_pkg() {
  
  // @@protoc_insertion_point(field_mutable:PokerGame.msg_package.req_pkg)
  return req_pkg_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* msg_package::release_req_pkg() {
  // @@protoc_insertion_point(field_release:PokerGame.msg_package.req_pkg)
  
  return req_pkg_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void msg_package::set_allocated_req_pkg(std::string* req_pkg) {
  if (req_pkg != nullptr) {
    
  } else {
    
  }
  req_pkg_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), req_pkg);
  // @@protoc_insertion_point(field_set_allocated:PokerGame.msg_package.req_pkg)
}

// .PokerGame.response res_pkg = 5;
inline bool msg_package::has_res_pkg() const {
  return this != internal_default_instance() && res_pkg_ != nullptr;
}
inline void msg_package::clear_res_pkg() {
  if (GetArenaNoVirtual() == nullptr && res_pkg_ != nullptr) {
    delete res_pkg_;
  }
  res_pkg_ = nullptr;
}
inline const ::PokerGame::response& msg_package::res_pkg() const {
  const ::PokerGame::response* p = res_pkg_;
  // @@protoc_insertion_point(field_get:PokerGame.msg_package.res_pkg)
  return p != nullptr ? *p : *reinterpret_cast<const ::PokerGame::response*>(
      &::PokerGame::_response_default_instance_);
}
inline ::PokerGame::response* msg_package::release_res_pkg() {
  // @@protoc_insertion_point(field_release:PokerGame.msg_package.res_pkg)
  
  ::PokerGame::response* temp = res_pkg_;
  res_pkg_ = nullptr;
  return temp;
}
inline ::PokerGame::response* msg_package::mutable_res_pkg() {
  
  if (res_pkg_ == nullptr) {
    auto* p = CreateMaybeMessage<::PokerGame::response>(GetArenaNoVirtual());
    res_pkg_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerGame.msg_package.res_pkg)
  return res_pkg_;
}
inline void msg_package::set_allocated_res_pkg(::PokerGame::response* res_pkg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete res_pkg_;
  }
  if (res_pkg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      res_pkg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, res_pkg, submessage_arena);
    }
    
  } else {
    
  }
  res_pkg_ = res_pkg;
  // @@protoc_insertion_point(field_set_allocated:PokerGame.msg_package.res_pkg)
}

// -------------------------------------------------------------------

// response

// .PokerGame.RET_CODE ret = 1;
inline void response::clear_ret() {
  ret_ = 0;
}
inline ::PokerGame::RET_CODE response::ret() const {
  // @@protoc_insertion_point(field_get:PokerGame.response.ret)
  return static_cast< ::PokerGame::RET_CODE >(ret_);
}
inline void response::set_ret(::PokerGame::RET_CODE value) {
  
  ret_ = value;
  // @@protoc_insertion_point(field_set:PokerGame.response.ret)
}

// string reson = 2;
inline void response::clear_reson() {
  reson_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& response::reson() const {
  // @@protoc_insertion_point(field_get:PokerGame.response.reson)
  return reson_.GetNoArena();
}
inline void response::set_reson(const std::string& value) {
  
  reson_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PokerGame.response.reson)
}
inline void response::set_reson(std::string&& value) {
  
  reson_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PokerGame.response.reson)
}
inline void response::set_reson(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  reson_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PokerGame.response.reson)
}
inline void response::set_reson(const char* value, size_t size) {
  
  reson_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PokerGame.response.reson)
}
inline std::string* response::mutable_reson() {
  
  // @@protoc_insertion_point(field_mutable:PokerGame.response.reson)
  return reson_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* response::release_reson() {
  // @@protoc_insertion_point(field_release:PokerGame.response.reson)
  
  return reson_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void response::set_allocated_reson(std::string* reson) {
  if (reson != nullptr) {
    
  } else {
    
  }
  reson_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reson);
  // @@protoc_insertion_point(field_set_allocated:PokerGame.response.reson)
}

// bytes pkg = 3;
inline void response::clear_pkg() {
  pkg_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& response::pkg() const {
  // @@protoc_insertion_point(field_get:PokerGame.response.pkg)
  return pkg_.GetNoArena();
}
inline void response::set_pkg(const std::string& value) {
  
  pkg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PokerGame.response.pkg)
}
inline void response::set_pkg(std::string&& value) {
  
  pkg_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PokerGame.response.pkg)
}
inline void response::set_pkg(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  pkg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PokerGame.response.pkg)
}
inline void response::set_pkg(const void* value, size_t size) {
  
  pkg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PokerGame.response.pkg)
}
inline std::string* response::mutable_pkg() {
  
  // @@protoc_insertion_point(field_mutable:PokerGame.response.pkg)
  return pkg_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* response::release_pkg() {
  // @@protoc_insertion_point(field_release:PokerGame.response.pkg)
  
  return pkg_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void response::set_allocated_pkg(std::string* pkg) {
  if (pkg != nullptr) {
    
  } else {
    
  }
  pkg_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pkg);
  // @@protoc_insertion_point(field_set_allocated:PokerGame.response.pkg)
}

// -------------------------------------------------------------------

// create_room

// int32 room_id = 1;
inline void create_room::clear_room_id() {
  room_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 create_room::room_id() const {
  // @@protoc_insertion_point(field_get:PokerGame.create_room.room_id)
  return room_id_;
}
inline void create_room::set_room_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  room_id_ = value;
  // @@protoc_insertion_point(field_set:PokerGame.create_room.room_id)
}

// .PokerGame.room_conf conf = 2;
inline bool create_room::has_conf() const {
  return this != internal_default_instance() && conf_ != nullptr;
}
inline void create_room::clear_conf() {
  if (GetArenaNoVirtual() == nullptr && conf_ != nullptr) {
    delete conf_;
  }
  conf_ = nullptr;
}
inline const ::PokerGame::room_conf& create_room::conf() const {
  const ::PokerGame::room_conf* p = conf_;
  // @@protoc_insertion_point(field_get:PokerGame.create_room.conf)
  return p != nullptr ? *p : *reinterpret_cast<const ::PokerGame::room_conf*>(
      &::PokerGame::_room_conf_default_instance_);
}
inline ::PokerGame::room_conf* create_room::release_conf() {
  // @@protoc_insertion_point(field_release:PokerGame.create_room.conf)
  
  ::PokerGame::room_conf* temp = conf_;
  conf_ = nullptr;
  return temp;
}
inline ::PokerGame::room_conf* create_room::mutable_conf() {
  
  if (conf_ == nullptr) {
    auto* p = CreateMaybeMessage<::PokerGame::room_conf>(GetArenaNoVirtual());
    conf_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerGame.create_room.conf)
  return conf_;
}
inline void create_room::set_allocated_conf(::PokerGame::room_conf* conf) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete conf_;
  }
  if (conf) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      conf = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, conf, submessage_arena);
    }
    
  } else {
    
  }
  conf_ = conf;
  // @@protoc_insertion_point(field_set_allocated:PokerGame.create_room.conf)
}

// -------------------------------------------------------------------

// room_conf

// bool joker = 1;
inline void room_conf::clear_joker() {
  joker_ = false;
}
inline bool room_conf::joker() const {
  // @@protoc_insertion_point(field_get:PokerGame.room_conf.joker)
  return joker_;
}
inline void room_conf::set_joker(bool value) {
  
  joker_ = value;
  // @@protoc_insertion_point(field_set:PokerGame.room_conf.joker)
}

// bool dealer = 2;
inline void room_conf::clear_dealer() {
  dealer_ = false;
}
inline bool room_conf::dealer() const {
  // @@protoc_insertion_point(field_get:PokerGame.room_conf.dealer)
  return dealer_;
}
inline void room_conf::set_dealer(bool value) {
  
  dealer_ = value;
  // @@protoc_insertion_point(field_set:PokerGame.room_conf.dealer)
}

// int32 players_num = 3;
inline void room_conf::clear_players_num() {
  players_num_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 room_conf::players_num() const {
  // @@protoc_insertion_point(field_get:PokerGame.room_conf.players_num)
  return players_num_;
}
inline void room_conf::set_players_num(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  players_num_ = value;
  // @@protoc_insertion_point(field_set:PokerGame.room_conf.players_num)
}

// int32 pokers_num = 4;
inline void room_conf::clear_pokers_num() {
  pokers_num_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 room_conf::pokers_num() const {
  // @@protoc_insertion_point(field_get:PokerGame.room_conf.pokers_num)
  return pokers_num_;
}
inline void room_conf::set_pokers_num(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  pokers_num_ = value;
  // @@protoc_insertion_point(field_set:PokerGame.room_conf.pokers_num)
}

// int32 type = 5;
inline void room_conf::clear_type() {
  type_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 room_conf::type() const {
  // @@protoc_insertion_point(field_get:PokerGame.room_conf.type)
  return type_;
}
inline void room_conf::set_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:PokerGame.room_conf.type)
}

// int32 deal_num = 6;
inline void room_conf::clear_deal_num() {
  deal_num_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 room_conf::deal_num() const {
  // @@protoc_insertion_point(field_get:PokerGame.room_conf.deal_num)
  return deal_num_;
}
inline void room_conf::set_deal_num(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  deal_num_ = value;
  // @@protoc_insertion_point(field_set:PokerGame.room_conf.deal_num)
}

// -------------------------------------------------------------------

// seats_info

// int32 id = 1;
inline void seats_info::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 seats_info::id() const {
  // @@protoc_insertion_point(field_get:PokerGame.seats_info.id)
  return id_;
}
inline void seats_info::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:PokerGame.seats_info.id)
}

// int32 user_id = 2;
inline void seats_info::clear_user_id() {
  user_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 seats_info::user_id() const {
  // @@protoc_insertion_point(field_get:PokerGame.seats_info.user_id)
  return user_id_;
}
inline void seats_info::set_user_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  user_id_ = value;
  // @@protoc_insertion_point(field_set:PokerGame.seats_info.user_id)
}

// string hands = 3;
inline void seats_info::clear_hands() {
  hands_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& seats_info::hands() const {
  // @@protoc_insertion_point(field_get:PokerGame.seats_info.hands)
  return hands_.GetNoArena();
}
inline void seats_info::set_hands(const std::string& value) {
  
  hands_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PokerGame.seats_info.hands)
}
inline void seats_info::set_hands(std::string&& value) {
  
  hands_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PokerGame.seats_info.hands)
}
inline void seats_info::set_hands(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  hands_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PokerGame.seats_info.hands)
}
inline void seats_info::set_hands(const char* value, size_t size) {
  
  hands_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PokerGame.seats_info.hands)
}
inline std::string* seats_info::mutable_hands() {
  
  // @@protoc_insertion_point(field_mutable:PokerGame.seats_info.hands)
  return hands_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* seats_info::release_hands() {
  // @@protoc_insertion_point(field_release:PokerGame.seats_info.hands)
  
  return hands_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void seats_info::set_allocated_hands(std::string* hands) {
  if (hands != nullptr) {
    
  } else {
    
  }
  hands_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hands);
  // @@protoc_insertion_point(field_set_allocated:PokerGame.seats_info.hands)
}

// int32 hands_num = 4;
inline void seats_info::clear_hands_num() {
  hands_num_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 seats_info::hands_num() const {
  // @@protoc_insertion_point(field_get:PokerGame.seats_info.hands_num)
  return hands_num_;
}
inline void seats_info::set_hands_num(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  hands_num_ = value;
  // @@protoc_insertion_point(field_set:PokerGame.seats_info.hands_num)
}

// string play_cards = 5;
inline void seats_info::clear_play_cards() {
  play_cards_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& seats_info::play_cards() const {
  // @@protoc_insertion_point(field_get:PokerGame.seats_info.play_cards)
  return play_cards_.GetNoArena();
}
inline void seats_info::set_play_cards(const std::string& value) {
  
  play_cards_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PokerGame.seats_info.play_cards)
}
inline void seats_info::set_play_cards(std::string&& value) {
  
  play_cards_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PokerGame.seats_info.play_cards)
}
inline void seats_info::set_play_cards(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  play_cards_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PokerGame.seats_info.play_cards)
}
inline void seats_info::set_play_cards(const char* value, size_t size) {
  
  play_cards_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PokerGame.seats_info.play_cards)
}
inline std::string* seats_info::mutable_play_cards() {
  
  // @@protoc_insertion_point(field_mutable:PokerGame.seats_info.play_cards)
  return play_cards_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* seats_info::release_play_cards() {
  // @@protoc_insertion_point(field_release:PokerGame.seats_info.play_cards)
  
  return play_cards_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void seats_info::set_allocated_play_cards(std::string* play_cards) {
  if (play_cards != nullptr) {
    
  } else {
    
  }
  play_cards_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), play_cards);
  // @@protoc_insertion_point(field_set_allocated:PokerGame.seats_info.play_cards)
}

// -------------------------------------------------------------------

// game_info

// int32 state = 1;
inline void game_info::clear_state() {
  state_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 game_info::state() const {
  // @@protoc_insertion_point(field_get:PokerGame.game_info.state)
  return state_;
}
inline void game_info::set_state(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  state_ = value;
  // @@protoc_insertion_point(field_set:PokerGame.game_info.state)
}

// .PokerGame.room_conf conf = 2;
inline bool game_info::has_conf() const {
  return this != internal_default_instance() && conf_ != nullptr;
}
inline void game_info::clear_conf() {
  if (GetArenaNoVirtual() == nullptr && conf_ != nullptr) {
    delete conf_;
  }
  conf_ = nullptr;
}
inline const ::PokerGame::room_conf& game_info::conf() const {
  const ::PokerGame::room_conf* p = conf_;
  // @@protoc_insertion_point(field_get:PokerGame.game_info.conf)
  return p != nullptr ? *p : *reinterpret_cast<const ::PokerGame::room_conf*>(
      &::PokerGame::_room_conf_default_instance_);
}
inline ::PokerGame::room_conf* game_info::release_conf() {
  // @@protoc_insertion_point(field_release:PokerGame.game_info.conf)
  
  ::PokerGame::room_conf* temp = conf_;
  conf_ = nullptr;
  return temp;
}
inline ::PokerGame::room_conf* game_info::mutable_conf() {
  
  if (conf_ == nullptr) {
    auto* p = CreateMaybeMessage<::PokerGame::room_conf>(GetArenaNoVirtual());
    conf_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerGame.game_info.conf)
  return conf_;
}
inline void game_info::set_allocated_conf(::PokerGame::room_conf* conf) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete conf_;
  }
  if (conf) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      conf = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, conf, submessage_arena);
    }
    
  } else {
    
  }
  conf_ = conf;
  // @@protoc_insertion_point(field_set_allocated:PokerGame.game_info.conf)
}

// repeated .PokerGame.seats_info seats = 3;
inline int game_info::seats_size() const {
  return seats_.size();
}
inline void game_info::clear_seats() {
  seats_.Clear();
}
inline ::PokerGame::seats_info* game_info::mutable_seats(int index) {
  // @@protoc_insertion_point(field_mutable:PokerGame.game_info.seats)
  return seats_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PokerGame::seats_info >*
game_info::mutable_seats() {
  // @@protoc_insertion_point(field_mutable_list:PokerGame.game_info.seats)
  return &seats_;
}
inline const ::PokerGame::seats_info& game_info::seats(int index) const {
  // @@protoc_insertion_point(field_get:PokerGame.game_info.seats)
  return seats_.Get(index);
}
inline ::PokerGame::seats_info* game_info::add_seats() {
  // @@protoc_insertion_point(field_add:PokerGame.game_info.seats)
  return seats_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PokerGame::seats_info >&
game_info::seats() const {
  // @@protoc_insertion_point(field_list:PokerGame.game_info.seats)
  return seats_;
}

// string comm_cards = 4;
inline void game_info::clear_comm_cards() {
  comm_cards_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& game_info::comm_cards() const {
  // @@protoc_insertion_point(field_get:PokerGame.game_info.comm_cards)
  return comm_cards_.GetNoArena();
}
inline void game_info::set_comm_cards(const std::string& value) {
  
  comm_cards_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PokerGame.game_info.comm_cards)
}
inline void game_info::set_comm_cards(std::string&& value) {
  
  comm_cards_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PokerGame.game_info.comm_cards)
}
inline void game_info::set_comm_cards(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  comm_cards_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PokerGame.game_info.comm_cards)
}
inline void game_info::set_comm_cards(const char* value, size_t size) {
  
  comm_cards_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PokerGame.game_info.comm_cards)
}
inline std::string* game_info::mutable_comm_cards() {
  
  // @@protoc_insertion_point(field_mutable:PokerGame.game_info.comm_cards)
  return comm_cards_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* game_info::release_comm_cards() {
  // @@protoc_insertion_point(field_release:PokerGame.game_info.comm_cards)
  
  return comm_cards_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void game_info::set_allocated_comm_cards(std::string* comm_cards) {
  if (comm_cards != nullptr) {
    
  } else {
    
  }
  comm_cards_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), comm_cards);
  // @@protoc_insertion_point(field_set_allocated:PokerGame.game_info.comm_cards)
}

// -------------------------------------------------------------------

// config_room

// .PokerGame.room_conf conf = 1;
inline bool config_room::has_conf() const {
  return this != internal_default_instance() && conf_ != nullptr;
}
inline void config_room::clear_conf() {
  if (GetArenaNoVirtual() == nullptr && conf_ != nullptr) {
    delete conf_;
  }
  conf_ = nullptr;
}
inline const ::PokerGame::room_conf& config_room::conf() const {
  const ::PokerGame::room_conf* p = conf_;
  // @@protoc_insertion_point(field_get:PokerGame.config_room.conf)
  return p != nullptr ? *p : *reinterpret_cast<const ::PokerGame::room_conf*>(
      &::PokerGame::_room_conf_default_instance_);
}
inline ::PokerGame::room_conf* config_room::release_conf() {
  // @@protoc_insertion_point(field_release:PokerGame.config_room.conf)
  
  ::PokerGame::room_conf* temp = conf_;
  conf_ = nullptr;
  return temp;
}
inline ::PokerGame::room_conf* config_room::mutable_conf() {
  
  if (conf_ == nullptr) {
    auto* p = CreateMaybeMessage<::PokerGame::room_conf>(GetArenaNoVirtual());
    conf_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PokerGame.config_room.conf)
  return conf_;
}
inline void config_room::set_allocated_conf(::PokerGame::room_conf* conf) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete conf_;
  }
  if (conf) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      conf = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, conf, submessage_arena);
    }
    
  } else {
    
  }
  conf_ = conf;
  // @@protoc_insertion_point(field_set_allocated:PokerGame.config_room.conf)
}

// -------------------------------------------------------------------

// play_cards

// string cards = 1;
inline void play_cards::clear_cards() {
  cards_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& play_cards::cards() const {
  // @@protoc_insertion_point(field_get:PokerGame.play_cards.cards)
  return cards_.GetNoArena();
}
inline void play_cards::set_cards(const std::string& value) {
  
  cards_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PokerGame.play_cards.cards)
}
inline void play_cards::set_cards(std::string&& value) {
  
  cards_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PokerGame.play_cards.cards)
}
inline void play_cards::set_cards(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  cards_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PokerGame.play_cards.cards)
}
inline void play_cards::set_cards(const char* value, size_t size) {
  
  cards_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PokerGame.play_cards.cards)
}
inline std::string* play_cards::mutable_cards() {
  
  // @@protoc_insertion_point(field_mutable:PokerGame.play_cards.cards)
  return cards_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* play_cards::release_cards() {
  // @@protoc_insertion_point(field_release:PokerGame.play_cards.cards)
  
  return cards_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void play_cards::set_allocated_cards(std::string* cards) {
  if (cards != nullptr) {
    
  } else {
    
  }
  cards_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cards);
  // @@protoc_insertion_point(field_set_allocated:PokerGame.play_cards.cards)
}

// -------------------------------------------------------------------

// fold_cards

// string cards = 1;
inline void fold_cards::clear_cards() {
  cards_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& fold_cards::cards() const {
  // @@protoc_insertion_point(field_get:PokerGame.fold_cards.cards)
  return cards_.GetNoArena();
}
inline void fold_cards::set_cards(const std::string& value) {
  
  cards_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PokerGame.fold_cards.cards)
}
inline void fold_cards::set_cards(std::string&& value) {
  
  cards_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PokerGame.fold_cards.cards)
}
inline void fold_cards::set_cards(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  cards_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PokerGame.fold_cards.cards)
}
inline void fold_cards::set_cards(const char* value, size_t size) {
  
  cards_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PokerGame.fold_cards.cards)
}
inline std::string* fold_cards::mutable_cards() {
  
  // @@protoc_insertion_point(field_mutable:PokerGame.fold_cards.cards)
  return cards_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* fold_cards::release_cards() {
  // @@protoc_insertion_point(field_release:PokerGame.fold_cards.cards)
  
  return cards_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void fold_cards::set_allocated_cards(std::string* cards) {
  if (cards != nullptr) {
    
  } else {
    
  }
  cards_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cards);
  // @@protoc_insertion_point(field_set_allocated:PokerGame.fold_cards.cards)
}

// -------------------------------------------------------------------

// deal_cards

// string cards = 1;
inline void deal_cards::clear_cards() {
  cards_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& deal_cards::cards() const {
  // @@protoc_insertion_point(field_get:PokerGame.deal_cards.cards)
  return cards_.GetNoArena();
}
inline void deal_cards::set_cards(const std::string& value) {
  
  cards_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PokerGame.deal_cards.cards)
}
inline void deal_cards::set_cards(std::string&& value) {
  
  cards_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PokerGame.deal_cards.cards)
}
inline void deal_cards::set_cards(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  cards_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PokerGame.deal_cards.cards)
}
inline void deal_cards::set_cards(const char* value, size_t size) {
  
  cards_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PokerGame.deal_cards.cards)
}
inline std::string* deal_cards::mutable_cards() {
  
  // @@protoc_insertion_point(field_mutable:PokerGame.deal_cards.cards)
  return cards_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* deal_cards::release_cards() {
  // @@protoc_insertion_point(field_release:PokerGame.deal_cards.cards)
  
  return cards_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void deal_cards::set_allocated_cards(std::string* cards) {
  if (cards != nullptr) {
    
  } else {
    
  }
  cards_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cards);
  // @@protoc_insertion_point(field_set_allocated:PokerGame.deal_cards.cards)
}

// -------------------------------------------------------------------

// get_cards

// int32 num = 1;
inline void get_cards::clear_num() {
  num_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 get_cards::num() const {
  // @@protoc_insertion_point(field_get:PokerGame.get_cards.num)
  return num_;
}
inline void get_cards::set_num(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  num_ = value;
  // @@protoc_insertion_point(field_set:PokerGame.get_cards.num)
}

// string cards = 2;
inline void get_cards::clear_cards() {
  cards_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& get_cards::cards() const {
  // @@protoc_insertion_point(field_get:PokerGame.get_cards.cards)
  return cards_.GetNoArena();
}
inline void get_cards::set_cards(const std::string& value) {
  
  cards_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PokerGame.get_cards.cards)
}
inline void get_cards::set_cards(std::string&& value) {
  
  cards_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PokerGame.get_cards.cards)
}
inline void get_cards::set_cards(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  cards_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PokerGame.get_cards.cards)
}
inline void get_cards::set_cards(const char* value, size_t size) {
  
  cards_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PokerGame.get_cards.cards)
}
inline std::string* get_cards::mutable_cards() {
  
  // @@protoc_insertion_point(field_mutable:PokerGame.get_cards.cards)
  return cards_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* get_cards::release_cards() {
  // @@protoc_insertion_point(field_release:PokerGame.get_cards.cards)
  
  return cards_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void get_cards::set_allocated_cards(std::string* cards) {
  if (cards != nullptr) {
    
  } else {
    
  }
  cards_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cards);
  // @@protoc_insertion_point(field_set_allocated:PokerGame.get_cards.cards)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace PokerGame

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::PokerGame::PokerGameID> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PokerGame::PokerGameID>() {
  return ::PokerGame::PokerGameID_descriptor();
}
template <> struct is_proto_enum< ::PokerGame::RET_CODE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PokerGame::RET_CODE>() {
  return ::PokerGame::RET_CODE_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_poker_2eproto
